import ExteriorPowers.ProjectiveSpaceManifold
import Mathlib.Geometry.Manifold.Instances.UnitsOfNormedAlgebra
import Mathlib.Analysis.NormedSpace.OperatorNorm
import ExteriorPowers.contMDiff_openEmbedding

open scoped LinearAlgebra.Projectivization
open Classical
noncomputable section

universe u

variable {ùïú E : Type u} [NontriviallyNormedField ùïú] [NormedAddCommGroup E] [NormedSpace ùïú E]
  [CompleteSpace ùïú] [Nontrivial E] [SeparatingDual ùïú E]


namespace ProjectiveSpace

/- We prove that the Projectivization.mk' map from Estar to ‚Ñô(E) is smooth. This is useful to construct
smooth maps to ‚Ñô(E).-/


variable (ùïú E)

lemma Smooth.quotientMap :
ContMDiff (modelWithCornersSelf ùïú E) (E' := LinearMap.ker (Chi ùïú E)) (M' := ‚Ñô ùïú E)
(ModelHyperplane ùïú E) ‚ä§ (Projectivization.mk' ùïú) := by
  rw [contMDiff_iff]
  constructor
  . rw [continuous_def]
    intro U
    rw [isOpen_coinduced]
    simp only [ne_eq, imp_self]
  . intro u x
    set œÜ := PhiForChart x
    set hœÜ := PhiForChart_prop x
    have hœÜ' : œÜ  ‚â† 0 := NonzeroPhiOfPhiEqOne hœÜ
    unfold ModelHyperplane
    simp only [extChartAt, PartialHomeomorph.extend, modelWithCornersSelf_localEquiv,
      PartialEquiv.trans_refl, ne_eq, OpenEmbedding.toPartialHomeomorph_source,
      PartialHomeomorph.singletonChartedSpace_chartAt_eq, PartialHomeomorph.coe_coe_symm,
      OpenEmbedding.toPartialHomeomorph_target, Subtype.range_coe_subtype]
    unfold chartAt ChartedSpace.chartAt ProjectiveSpace.instChartedSpaceProjectiveSpace
    simp only
    rw [ProjectiveSpace.ChartAt_source]
    apply ContDiffOn.mono (s := {u : E | œÜ u ‚â† 0})
    swap
    . intro v
      simp only [Set.mem_inter_iff, Set.mem_preimage, Projectivization.mk'_eq_mk, Set.mem_setOf_eq, and_imp]
      intro hv1 hv2
      conv at hv2 => congr
                     congr
                     erw [‚Üê(Estar.chartAt.inverse u hv1)]
      rw [‚ÜêGoodsetPreimage] at hv2
      exact hv2
    . unfold ProjectiveSpace.ChartAt
      change ContDiffOn ùïú ‚ä§ ((_ ‚àò (ProjectiveSpace.ChartAt_aux x)) ‚àò _ ‚àò _) _
      refine @ContDiffOn.continuousLinearMap_comp ùïú _ E _ _ (LinearMap.ker œÜ) _ _
         (LinearMap.ker (Chi ùïú E)) _ _ _ _ ‚ä§
         (OneIsomorphismBetweenTwoClosedHyperplanes hœÜ' (hChi ùïú E)) ?_
      set g := fun (u : E) => ContinuousRetractionOnHyperplane (PhiForChart_prop x) (((œÜ x.rep) / (œÜ u)) ‚Ä¢ u - x.rep)
      refine ContDiffOn.congr (f := g) ?_ ?_
      swap
      . intro v hv
        have hvnz : v ‚â† 0 := NonzeroOfNonzeroPhi hv
        simp only [Function.comp_apply, Projectivization.mk'_eq_mk, ne_eq, map_sub, map_smul]
        conv => lhs
                congr
                rfl
                congr
                erw [‚Üê(Estar.chartAt.inverse u hvnz)]
        unfold ProjectiveSpace.ChartAt_aux Chart_PartialHomeomorph Chart_PartialEquiv Chart
        simp only [map_sub, map_smul, Set.top_eq_univ, PartialHomeomorph.mk_coe, sub_left_inj]
        rw [hœÜ]
        apply Projectivization_vs_LinearMap (œÜ : E ‚Üí‚Çó[ùïú] ùïú) (Projectivization.rep_nonzero _) hvnz
        rw [Projectivization.mk_rep]
      . apply ContDiffOn.continuousLinearMap_comp
        apply ContDiffOn.sub
        . simp_rw [hœÜ, one_div]
          apply ContDiffOn.smul
          . apply ContDiffOn.inv
            . apply ContDiff.contDiffOn
              apply ContinuousLinearMap.contDiff
            . exact fun _ hu => hu
          . exact contDiffOn_id
        . apply contDiffOn_const


variable {ùïú E}

/- The Projectivization.mk' map admits Partial smooth sections: if we have a nonzero continuous linear form œÜ
and a point x in ‚Ñô(E) such that œÜ(x.rep)=1, then the map y => (1 / œÜ(y.rep)) ‚Ä¢ y.rep sends
Goodset œÜ to {œÜ = 1}, hence to E-{0}, and it is a section of Projectivization.mk'. We introduce it
and prove that it is smooth.-/

def LocalSection (œÜ : E ‚ÜíL[ùïú] ùïú) :
‚Ñô ùïú E ‚Üí {u : E // u ‚â† 0} := by
  intro y
  by_cases hgood : œÜ y.rep = 0
  . exact Classical.choice inferInstance
  . refine ‚ü®(1 / (œÜ y.rep)) ‚Ä¢ y.rep, ?_‚ü©
    simp only [one_div, ne_eq, Set.mem_setOf_eq, smul_eq_zero, inv_eq_zero]
    rw [not_or, and_iff_right hgood]
    exact NonzeroOfNonzeroPhi hgood

lemma LocalSectionIsSection (œÜ : E ‚ÜíL[ùïú] ùïú) {y : ‚Ñô ùïú E} (hy : y ‚àà Goodset œÜ) :
Projectivization.mk' ùïú (ProjectiveSpace.LocalSection œÜ y) = y := by
  unfold ProjectiveSpace.LocalSection
  change œÜ (y.rep) ‚â† 0 at hy
  simp only [hy, one_div, dite_false, Projectivization.mk'_eq_mk]
  conv => rhs
          rw [‚Üê(Projectivization.mk_rep y)]
  apply Eq.symm
  rw [Projectivization.mk_eq_mk_iff]
  existsi Units.mk0 (œÜ y.rep) hy
  simp only [Units.smul_mk0, ne_eq]
  rw [smul_smul]
  simp only [ne_eq, hy, not_false_eq_true, mul_inv_cancel, one_smul]


def RetractionOnHyperplane {œÜ : E ‚ÜíL[ùïú] ùïú} (hœÜ : œÜ ‚â† 0) : {u : E | u ‚â† 0} ‚Üí {u : E | œÜ u = 1} := by
  intro u
  by_cases h : œÜ u = 0
  . exact ‚ü®Classical.choose (NonzeroExistsEqOne hœÜ), Classical.choose_spec (NonzeroExistsEqOne hœÜ)‚ü©
  . refine ‚ü®(1 / (œÜ u)) ‚Ä¢ u.1, ?_‚ü©
    simp only [one_div, Set.mem_setOf_eq, map_smul, smul_eq_mul, ne_eq, h, not_false_eq_true, inv_mul_cancel]

lemma RetractionOnHyperplaneIsContinuousOn {œÜ : E ‚ÜíL[ùïú] ùïú} (hœÜ : œÜ ‚â† 0) :
ContinuousOn (RetractionOnHyperplane hœÜ) {u : {u : E | u ‚â† 0} | œÜ u.1 ‚â† 0} := by
  rw [continuousOn_iff_continuous_restrict, continuous_induced_rng]
  set f : {u : {u : E | u ‚â† 0} | œÜ u.1 ‚â† 0} ‚Üí E :=  fun u => (1 / œÜ u.1) ‚Ä¢ u.1.1
  have heq : ‚àÄ u, f u = (Subtype.val ‚àò Set.restrict {u : {u : E | u ‚â† 0} | œÜ u.1 ‚â† 0} (RetractionOnHyperplane hœÜ)) u := by
    intro u
    simp only [ne_eq, Set.coe_setOf, Set.mem_setOf_eq, Function.comp_apply, Set.restrict_apply]
    unfold RetractionOnHyperplane
    have hu : œÜ u ‚â† 0 := u.2
    simp only [one_div, hu, Set.mem_setOf_eq, dite_false]
  refine Continuous.congr ?_ heq
  apply Continuous.smul
  . simp_rw [one_div]
    apply Continuous.inv‚ÇÄ
    . continuity
    . exact fun u => u.2
  . continuity

def InclusionHyperplane (œÜ : E ‚ÜíL[ùïú] ùïú) : {u : E | œÜ u = 1} ‚Üí {u : E | u ‚â† 0} := by
  intro ‚ü®u, hu‚ü©
  refine ‚ü®u, ?_‚ü©
  change u ‚â† 0
  by_contra habs
  rw [habs] at hu
  simp only [Set.mem_setOf_eq, map_zero, zero_ne_one] at hu

lemma InclusionHyperplaneIsContinuous (œÜ : E ‚ÜíL[ùïú] ùïú) :
Continuous (InclusionHyperplane œÜ) := by
  unfold InclusionHyperplane
  simp only [Set.coe_setOf, Set.mem_setOf_eq]
  continuity

lemma LocalSection_IsContinuousOn {œÜ : E ‚ÜíL[ùïú] ùïú} (hœÜ : œÜ ‚â† 0) :
ContinuousOn (ProjectiveSpace.LocalSection œÜ) (Goodset œÜ) := by
  rw [continuousOn_open_iff (GoodsetIsOpen œÜ)]
  intro U hU
  rw [isOpen_coinduced]
  have heq : (Projectivization.mk' ùïú) ‚Åª¬π' (Goodset œÜ ‚à© (LocalSection œÜ) ‚Åª¬π' U) = {u | œÜ u.1 ‚â† 0} ‚à©
    (RetractionOnHyperplane hœÜ) ‚Åª¬π' ((InclusionHyperplane œÜ) ‚Åª¬π' U) := by
    ext u
    simp only [Set.preimage_inter, Set.mem_inter_iff, Set.mem_preimage, Projectivization.mk'_eq_mk,
      Set.coe_setOf]
    rw [‚ÜêGoodsetPreimage]
    change _ ‚Üî œÜ u ‚â† 0 ‚àß _
    simp only [and_congr_right_iff]
    intro hu
    have hunz := NonzeroOfNonzeroPhi hu
    unfold RetractionOnHyperplane
    simp only [hu, Set.mem_setOf_eq, dite_false]
    unfold LocalSection
    rw [GoodsetPreimage œÜ hunz] at hu
    change œÜ _ ‚â† 0 at hu
    simp only [hu, dite_false, Set.mem_setOf_eq]
    have heq' : (1 / œÜ (Projectivization.mk ùïú u.1 hunz).rep) ‚Ä¢ (Projectivization.mk ùïú u.1 hunz).rep =
       (1/ œÜ u) ‚Ä¢ u.1 := by
      apply Projectivization_vs_LinearMap_cor
      rw [Projectivization.mk_rep]
    simp_rw [heq']
    unfold InclusionHyperplane
    simp only
  rw [heq]
  apply IsOpen.inter
  ¬∑ apply NonzeroPhiIsOpen'
  ¬∑ refine ContinuousOn.isOpen_preimage (RetractionOnHyperplaneIsContinuousOn hœÜ) ?_ ?_
      (IsOpen.preimage (InclusionHyperplaneIsContinuous œÜ) hU)
    apply NonzeroPhiIsOpen'
    rw [Set.preimage_subset_iff]
    intro v
    simp only [Set.coe_setOf, ne_eq, Set.mem_preimage, Set.mem_setOf_eq]
    unfold InclusionHyperplane
    simp only [ne_eq, Set.mem_setOf_eq]
    unfold RetractionOnHyperplane
    sorry

lemma LocalSection_IsSmoothOn (œÜ : E ‚ÜíL[ùïú] ùïú) :
ContMDiffOn (ModelHyperplane ùïú E) (modelWithCornersSelf ùïú E) ‚ä§ (ProjectiveSpace.LocalSection œÜ) (Goodset œÜ) := by
  by_cases hœÜ : œÜ = 0
  . rw [GoodsetZero hœÜ]
    apply contMDiffOn_of_locally_contMDiffOn
    simp only [Set.mem_empty_iff_false, Set.empty_inter, IsEmpty.forall_iff, implies_true]
  . match NonzeroExistsEqOne hœÜ with
    | ‚ü®v, hv‚ü© =>
      rw [contMDiffOn_iff_of_mem_maximalAtlas
      (e := (PartialHomeomorph.transHomeomorph
        (Chart_PartialHomeomorph hv) (ContinuousLinearEquiv.toHomeomorph
        (OneIsomorphismBetweenTwoClosedHyperplanes (NonzeroPhiOfPhiEqOne hv) (hChi ùïú E)))))
      (e' := (OpenEmbedding.toPartialHomeomorph (fun u => u.1) EstarToE))
      (by apply SmoothManifoldWithCorners.subset_maximalAtlas
          change _ ‚àà @atlas (LinearMap.ker (Chi ùïú E)) _ (‚Ñô ùïú E) _ _
          change _ ‚àà  {f | ‚àÉ (œÜ : E ‚ÜíL[ùïú] ùïú) (v : E) (hv : œÜ v = 1), f = PartialHomeomorph.transHomeomorph
              (Chart_PartialHomeomorph hv) (ContinuousLinearEquiv.toHomeomorph
              (OneIsomorphismBetweenTwoClosedHyperplanes (NonzeroPhiOfPhiEqOne hv) (hChi ùïú E)))}
          simp only [Set.mem_setOf_eq]
          existsi œÜ; existsi v; existsi hv
          rfl)
       (by apply SmoothManifoldWithCorners.subset_maximalAtlas
           change _ ‚àà {(OpenEmbedding.toPartialHomeomorph (fun u => u.1) EstarToE)}
           simp only [Set.mem_singleton_iff])
        (by rw [ProjectiveSpace.Chart_source])
        (by simp only [OpenEmbedding.toPartialHomeomorph_source]
            apply Set.mapsTo_univ)]
      constructor
      . exact ProjectiveSpace.LocalSection_IsContinuousOn hœÜ
      . apply ContDiffOn.mono (s := ‚ä§)
        swap
        . simp only [PartialHomeomorph.extend, ne_eq, PartialEquiv.coe_trans, ModelWithCorners.toPartialEquiv_coe,
          PartialHomeomorph.toFun_eq_coe, PartialHomeomorph.transHomeomorph_apply, ContinuousLinearEquiv.coe_toHomeomorph,
          Function.comp_apply, Set.top_eq_univ, Set.subset_univ]
        . set f : LinearMap.ker (Chi ùïú E) ‚Üí E := (fun u => v + u.1) ‚àò
            (OneIsomorphismBetweenTwoClosedHyperplanes hœÜ (hChi ùïú E)).symm
          apply ContDiffOn.congr (f := f)
          swap
          . intro u _
            simp only [ne_eq, PartialHomeomorph.extend, modelWithCornersSelf_localEquiv,
              PartialEquiv.trans_refl, PartialHomeomorph.toFun_eq_coe,
              OpenEmbedding.toPartialHomeomorph_apply, PartialEquiv.coe_trans_symm,
              PartialHomeomorph.coe_coe_symm, PartialHomeomorph.transHomeomorph_symm_apply,
              ContinuousLinearEquiv.symm_toHomeomorph, ContinuousLinearEquiv.coe_toHomeomorph,
              ModelWithCorners.toPartialEquiv_coe_symm, Function.comp_apply]
            unfold ModelHyperplane
            simp only [ne_eq, Set.coe_setOf, Set.mem_setOf_eq, modelWithCornersSelf_coe_symm, id_eq]
            generalize (OneIsomorphismBetweenTwoClosedHyperplanes hœÜ (hChi ùïú E)).symm u = u
            have hu1 : œÜ (v + u.1) = 1 := by
              rw [map_add, hv, u.2, add_zero]
            have hu2 : œÜ (v + u.1) ‚â† 0 := by
              rw [hu1]
              exact one_ne_zero
            have hu3 : v + u.1 ‚â† 0 := NonzeroOfNonzeroPhi hu2
            unfold Chart_PartialHomeomorph Chart_PartialEquiv
            simp only [ne_eq, Set.coe_setOf, Set.mem_setOf_eq, Set.top_eq_univ, PartialHomeomorph.mk_coe_symm,
              PartialEquiv.coe_symm_mk]
            unfold InverseChart LocalSection
            have hgood : œÜ (Projectivization.mk ùïú (v + u.1) hu3).rep ‚â† 0 := by
              change Projectivization.mk ùïú (v + u.1) hu3 ‚àà Goodset œÜ
              rw [‚ÜêGoodsetPreimage]
              exact hu2
            simp only [ne_eq, Set.coe_setOf, Set.mem_setOf_eq, hgood, one_div, dite_false]
            rw [‚Üêone_div]
            have h : v + u.1 = (1 / œÜ (v + u.1)) ‚Ä¢ (v + u.1) := by
              rw [hu1, div_self, one_smul]
              exact one_ne_zero
            conv => rhs
                    rw [h]
            apply Projectivization_vs_LinearMap_cor
            rw [Projectivization.mk_rep]
          . rw [Set.top_eq_univ, contDiffOn_univ]
            change ContDiff ùïú ‚ä§ (_ ‚àò _)
            refine @ContDiff.comp_continuousLinearMap ùïú _ (LinearMap.ker œÜ) _ _ E _ _
              (LinearMap.ker (Chi ùïú E)) _ _ ‚ä§ (fun u => v + u.1)
              (OneIsomorphismBetweenTwoClosedHyperplanes hœÜ (hChi ùïú E)).symm ?_
            apply ContDiff.add
            . apply contDiff_const
            . exact ContinuousLinearMap.contDiff (Submodule.subtypeL (LinearMap.ker œÜ))

/- If f is map from ‚Ñô(E) to a manifold such that f ‚àò Projectivization.mk'is smooth, we prove that f is
smooth. This is useful to construct smooth maps from ‚Ñô(E).-/

lemma Smooth.mapFromProjectiveSpace {F : Type u} [NormedAddCommGroup F] [NormedSpace ùïú F] {H : Type u}
[TopologicalSpace H] {I : ModelWithCorners ùïú F H} {M : Type u} [TopologicalSpace M] [ChartedSpace H M]
[SmoothManifoldWithCorners I M] {f : ‚Ñô ùïú E ‚Üí M}
(hf : ContMDiff (modelWithCornersSelf ùïú E) I ‚ä§ (f ‚àò (Projectivization.mk' ùïú) : {u : E // u ‚â† 0} ‚Üí M)) :
@ContMDiff ùïú _ (LinearMap.ker (Chi ùïú E)) _ _ (LinearMap.ker (Chi ùïú E)) _ (ModelHyperplane ùïú E) (‚Ñô ùïú E) _
_ F _ _ H _ I M _ _ ‚ä§ f := by
  apply contMDiff_of_locally_contMDiffOn
  intro x
  set œÜ := PhiForChart x
  set hœÜ := PhiForChart_prop x
  exists Goodset œÜ
  rw [and_iff_right (GoodsetIsOpen œÜ)]
  constructor
  . change œÜ x.rep ‚â† 0
    rw [hœÜ]
    exact one_ne_zero
  . set g : ‚Ñô ùïú E ‚Üí M := f ‚àò (Projectivization.mk' ùïú) ‚àò (ProjectiveSpace.LocalSection œÜ) with hgdef
    have heq : ‚àÄ (y : ‚Ñô ùïú E), y ‚àà Goodset œÜ ‚Üí f y = g y := by
      intro y hy
      rw [hgdef]
      simp only [ne_eq, Function.comp_apply]
      rw [ProjectiveSpace.LocalSectionIsSection]
      exact hy
    refine ContMDiffOn.congr ?_ heq
    rw [hgdef, ‚ÜêFunction.comp.assoc]
    refine @ContMDiffOn.comp ùïú _ (LinearMap.ker (Chi ùïú E)) _ _ (LinearMap.ker (Chi ùïú E)) _
      (ModelHyperplane ùïú E) (‚Ñô ùïú E) _ _ E _ _ E _ (modelWithCornersSelf ùïú E)
      {u : E // u ‚â† 0} _ _
      F _ _ H _ I M _ _ (ProjectiveSpace.LocalSection œÜ) (Goodset œÜ) ‚ä§ ‚ä§
      (f ‚àò (Projectivization.mk' ùïú)) (ContMDiff.contMDiffOn (s := ‚ä§) hf) ?_ ?_
    . exact ProjectiveSpace.LocalSection_IsSmoothOn œÜ
    . simp only [Set.top_eq_univ, Set.preimage_univ, Set.subset_univ]


lemma Smooth.mapFromProductProjectiveSpace {F G : Type u} [NormedAddCommGroup F] [NormedSpace ùïú F]
[NormedAddCommGroup G] [NormedSpace ùïú G] {H H' : Type u} [TopologicalSpace H] [TopologicalSpace H']
{I : ModelWithCorners ùïú F H} {I' : ModelWithCorners ùïú G H'} {M N : Type u} [TopologicalSpace M]
[ChartedSpace H M] [SmoothManifoldWithCorners I M] [TopologicalSpace N] [ChartedSpace H' N]
[SmoothManifoldWithCorners I' N]
{f : N √ó ‚Ñô ùïú E ‚Üí M}
(hf : ContMDiff (ModelWithCorners.prod I' (modelWithCornersSelf ùïú E)) I ‚ä§
(f ‚àò (Prod.map (fun x => x) (Projectivization.mk' ùïú)) : N √ó {u : E // u ‚â† 0} ‚Üí M)) :
ContMDiff (ModelWithCorners.prod I' (ModelHyperplane ùïú E)) I ‚ä§ f := by
  apply contMDiff_of_locally_contMDiffOn
  intro x
  set œÜ := PhiForChart x.2
  set hœÜ := PhiForChart_prop x.2
  existsi ‚ä§ √óÀ¢ (Goodset œÜ)
  constructor
  . apply IsOpen.prod
    . simp only [Set.top_eq_univ, isOpen_univ]
    . exact GoodsetIsOpen œÜ
  . constructor
    . erw [Set.mem_prod]
      simp only [Set.top_eq_univ, Set.mem_univ, true_and]
      change œÜ x.2.rep ‚â† 0
      rw [hœÜ]
      exact one_ne_zero
    . set g : N √ó ‚Ñô ùïú E ‚Üí M := f ‚àò (Prod.map (fun x => x)
        (Projectivization.mk' ùïú)) ‚àò (Prod.map (fun x => x) (ProjectiveSpace.LocalSection œÜ)) with hgdef
      have heq : ‚àÄ (y : N √ó ‚Ñô ùïú E), y ‚àà ‚ä§ √óÀ¢ (Goodset œÜ) ‚Üí f y = g y := by
        intro y hy
        simp only [ne_eq, Function.comp_apply, Prod_map]
        rw [LocalSectionIsSection œÜ (Set.mem_prod.mp hy).2]
      refine ContMDiffOn.congr ?_ heq
      rw [hgdef, ‚ÜêFunction.comp.assoc]
      have hf' := ContMDiff.contMDiffOn (s := ‚ä§) hf
      refine ContMDiffOn.comp (s := ‚ä§ √óÀ¢ (Goodset œÜ)) (t := ‚ä§) (M' := N √ó {u : E // u ‚â† 0}) hf' ?_ ?_
      . apply ContMDiffOn.prod_map (N' := {u : E // u ‚â† 0})
        . exact contMDiffOn_id
        . exact ProjectiveSpace.LocalSection_IsSmoothOn œÜ
      . simp only [Set.top_eq_univ, Set.preimage_univ, Set.subset_univ]


/- We define the action of GL(E) on ‚Ñô(E) and prove that it is a smooth action.-/


lemma ActionGL_aux (f : (E ‚ÜíL[ùïú] E)À£) {u : E} (hu : u ‚â† 0) : f.1 u ‚â† 0 := by
  set g := ContinuousLinearEquiv.ofUnit f
  change g u ‚â† 0
  simp only [ne_eq, AddEquivClass.map_eq_zero_iff]
  exact hu

variable (ùïú E)

def ActionGL : (E ‚ÜíL[ùïú] E)À£ √ó (‚Ñô ùïú E) ‚Üí (‚Ñô ùïú E) :=
fun ‚ü®g, x‚ü© => Projectivization.mk ùïú (g.1 x.rep) (ActionGL_aux g (Projectivization.rep_nonzero _))

/- We lift this action to E-{0}.-/

def ActionGLLift : (E ‚ÜíL[ùïú] E)À£ √ó {u : E // u ‚â† 0} ‚Üí {u : E // u ‚â† 0} := by
  intro ‚ü®g, u‚ü©
  refine ‚ü®g.1 u.1, ActionGL_aux g u.2‚ü©

/- We prove that the left is a lift.-/

lemma ActionGLLift_IsLift :
(ActionGL ùïú E ‚àò Prod.map (fun x => x) (Projectivization.mk' ùïú)) = Projectivization.mk' ùïú ‚àò ActionGLLift ùïú E := by
  ext ‚ü®g, u‚ü©
  unfold ActionGL ActionGLLift
  simp only [ne_eq, Function.comp_apply, Prod_map, Projectivization.mk'_eq_mk]
  rw [Projectivization.mk_eq_mk_iff]
  have heq := Projectivization.mk_rep (Projectivization.mk ùïú u.1 u.2)
  rw [Projectivization.mk_eq_mk_iff] at heq
  match heq with
  | ‚ü®a, ha‚ü© =>
    existsi a
    rw [‚Üêha]
    simp only [ne_eq, ContinuousLinearMap.map_smul_of_tower]

def ActionGLLift_extended : ((E ‚ÜíL[ùïú] E) √ó E) ‚Üí E := fun ‚ü®T, u‚ü© => T u

lemma ActionGLLift_extended_IsSmooth : ContDiff ùïú ‚ä§ (ActionGLLift_extended ùïú E) := by
  apply IsBoundedBilinearMap.contDiff
  unfold ActionGLLift_extended
  simp only
  exact isBoundedBilinearMap_apply

/- To get the smooth manifold structure on (E ‚ÜíL[ùïú] E), we need E to be complete.-/

variable [CompleteSpace E]

/- Smoothness of the lifted action.-/

lemma ActionGLLift_IsSmooth : ContMDiff (ModelWithCorners.prod (modelWithCornersSelf ùïú (E ‚ÜíL[ùïú] E))
  (modelWithCornersSelf ùïú E)) (modelWithCornersSelf ùïú E) ‚ä§ (ActionGLLift ùïú E) := by
  set e : PartialHomeomorph {u : E // u ‚â† 0} E := OpenEmbedding.toPartialHomeomorph (fun u => u.1) EstarToE
  have he : e ‚àà SmoothManifoldWithCorners.maximalAtlas (modelWithCornersSelf ùïú E) {u : E // u ‚â† 0} := by
    apply SmoothManifoldWithCorners.subset_maximalAtlas
    change _ ‚àà {(OpenEmbedding.toPartialHomeomorph (fun u => u.1) EstarToE)}
    simp only [Set.mem_singleton_iff]
  set e' : PartialHomeomorph (E ‚ÜíL[ùïú] E)À£ (E ‚ÜíL[ùïú] E) := OpenEmbedding.toPartialHomeomorph _ Units.openEmbedding_val
  have he' : e' ‚àà SmoothManifoldWithCorners.maximalAtlas (modelWithCornersSelf ùïú (E ‚ÜíL[ùïú] E)) (E ‚ÜíL[ùïú] E)À£ := by
    apply SmoothManifoldWithCorners.subset_maximalAtlas
    change _ ‚àà {(OpenEmbedding.toPartialHomeomorph _ Units.openEmbedding_val)}
    simp only [Set.mem_singleton_iff]
  have heq : ActionGLLift ùïú E = e.symm ‚àò (ActionGLLift_extended ùïú E) ‚àò (PartialHomeomorph.prod e' e) := by
    ext u
    unfold ActionGLLift ActionGLLift_extended
    simp only [ne_eq, PartialHomeomorph.prod_apply, OpenEmbedding.toPartialHomeomorph_apply, Function.comp_apply]
    have hnz : u.1.1 u.2 ‚â† 0 := ActionGL_aux u.1 u.2.2
    have h : u.1.1 u.2 = (‚ü®u.1.1 u.2, hnz‚ü© : {u : E | u ‚â† 0}).1 := by simp only
    rw [h, SetCoe.ext_iff, PartialHomeomorph.eq_symm_apply]
    haveI : Nonempty {u : E | u ‚â† 0} := by
      have hne : Nonempty {u : E // u ‚â† 0} := inferInstance
      exact hne
    rw [OpenEmbedding.toPartialHomeomorph_apply]
    simp only [ne_eq, Set.coe_setOf, Set.mem_setOf_eq, OpenEmbedding.toPartialHomeomorph_source, Set.mem_univ]
    simp only [ne_eq, Set.coe_setOf, OpenEmbedding.toPartialHomeomorph_target, Subtype.range_coe_subtype,
      Set.mem_setOf_eq]
    exact hnz
  rw [heq, ‚ÜêcontMDiffOn_univ]
  apply ContMDiffOn.comp (I' := modelWithCornersSelf ùïú E) (t := {u : E | u ‚â† 0})
  . have h : e.target = {u : E | u ‚â† 0} := by
      ext u
      simp only [ne_eq, OpenEmbedding.toPartialHomeomorph_target, Subtype.range_coe_subtype, Set.mem_setOf_eq]
    rw [‚Üêh]
    exact contMDiffOn_symm_of_mem_maximalAtlas he
  . rw [contMDiffOn_univ]
    apply ContMDiff.comp (I' := ModelWithCorners.prod (modelWithCornersSelf ùïú (E ‚ÜíL[ùïú] E)) (modelWithCornersSelf ùïú E))
    . rw [‚ÜêmodelWithCornersSelf_prod]
      erw [contMDiff_iff_contDiff]
      exact ActionGLLift_extended_IsSmooth ùïú E
    . apply ContMDiff.prod_map
      . rw [‚ÜêcontMDiffOn_univ]
        have h : Set.univ = e'.source := by
          ext u
          simp only [Set.mem_univ, OpenEmbedding.toPartialHomeomorph_source]
        rw [h]
        exact contMDiffOn_of_mem_maximalAtlas he'
      . rw [‚ÜêcontMDiffOn_univ]
        have h : Set.univ = e.source := by
          ext u
          simp only [ne_eq, Set.mem_univ, OpenEmbedding.toPartialHomeomorph_source]
        rw [h]
        exact contMDiffOn_of_mem_maximalAtlas he
  . intro u _
    simp only [PartialHomeomorph.prod_apply, OpenEmbedding.toPartialHomeomorph_apply, Set.preimage_setOf_eq,
      Function.comp_apply, Set.mem_setOf_eq]
    unfold ActionGLLift_extended
    simp only
    exact ActionGL_aux u.1 u.2.2


/- Smoothness of the action.-/

lemma ActionGLIsSmooth : ContMDiff (ModelWithCorners.prod (modelWithCornersSelf ùïú (E ‚ÜíL[ùïú] E)) (ModelHyperplane ùïú E))
  (ModelHyperplane ùïú E) ‚ä§ (ActionGL ùïú E) := by
  apply Smooth.mapFromProductProjectiveSpace
  rw [ActionGLLift_IsLift]
  apply ContMDiff.comp (E' := E) (I' := modelWithCornersSelf ùïú E) (M' := {u : E // u ‚â† 0})
  . exact Smooth.quotientMap ùïú E
  . exact ActionGLLift_IsSmooth ùïú E


end ProjectiveSpace
